// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: java.net.InetAddress
class InetAddress extends jni.JObject {
  @override
  late final jni.JObjType<InetAddress> $type = type;

  InetAddress.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"java/net/InetAddress");

  /// The type which includes information such as the signature of this class.
  static const type = $InetAddressType();
  static final _id_isMulticastAddress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isMulticastAddress", r"()Z");

  /// from: public boolean isMulticastAddress()
  bool isMulticastAddress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isMulticastAddress, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isAnyLocalAddress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isAnyLocalAddress", r"()Z");

  /// from: public boolean isAnyLocalAddress()
  bool isAnyLocalAddress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isAnyLocalAddress, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isLoopbackAddress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isLoopbackAddress", r"()Z");

  /// from: public boolean isLoopbackAddress()
  bool isLoopbackAddress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isLoopbackAddress, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isLinkLocalAddress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isLinkLocalAddress", r"()Z");

  /// from: public boolean isLinkLocalAddress()
  bool isLinkLocalAddress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isLinkLocalAddress, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isSiteLocalAddress = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isSiteLocalAddress", r"()Z");

  /// from: public boolean isSiteLocalAddress()
  bool isSiteLocalAddress() {
    return jni.Jni.accessors.callMethodWithArgs(reference,
        _id_isSiteLocalAddress, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isMCGlobal =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"isMCGlobal", r"()Z");

  /// from: public boolean isMCGlobal()
  bool isMCGlobal() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isMCGlobal, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isMCNodeLocal = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isMCNodeLocal", r"()Z");

  /// from: public boolean isMCNodeLocal()
  bool isMCNodeLocal() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isMCNodeLocal, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isMCLinkLocal = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isMCLinkLocal", r"()Z");

  /// from: public boolean isMCLinkLocal()
  bool isMCLinkLocal() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isMCLinkLocal, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isMCSiteLocal = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isMCSiteLocal", r"()Z");

  /// from: public boolean isMCSiteLocal()
  bool isMCSiteLocal() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isMCSiteLocal, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isMCOrgLocal = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isMCOrgLocal", r"()Z");

  /// from: public boolean isMCOrgLocal()
  bool isMCOrgLocal() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isMCOrgLocal, jni.JniCallType.booleanType, []).boolean;
  }

  static final _id_isReachable = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"isReachable", r"(I)Z");

  /// from: public boolean isReachable(int i)
  bool isReachable(
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_isReachable,
        jni.JniCallType.booleanType, [jni.JValueInt(i)]).boolean;
  }

  static final _id_isReachable1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"isReachable", r"(Ljava/net/NetworkInterface;II)Z");

  /// from: public boolean isReachable(java.net.NetworkInterface networkInterface, int i, int i1)
  bool isReachable1(
    jni.JObject networkInterface,
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isReachable1, jni.JniCallType.booleanType, [
      networkInterface.reference,
      jni.JValueInt(i),
      jni.JValueInt(i1)
    ]).boolean;
  }

  static final _id_getHostName = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"getHostName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getHostName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getHostName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHostName, jni.JniCallType.objectType, []).object);
  }

  static final _id_getCanonicalHostName = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getCanonicalHostName", r"()Ljava/lang/String;");

  /// from: public java.lang.String getCanonicalHostName()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getCanonicalHostName() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getCanonicalHostName,
        jni.JniCallType.objectType, []).object);
  }

  static final _id_getAddress =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"getAddress", r"()[B");

  /// from: public byte[] getAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JArray<jni.jbyte> getAddress() {
    return const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getAddress, jni.JniCallType.objectType, []).object);
  }

  static final _id_getHostAddress = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"getHostAddress", r"()Ljava/lang/String;");

  /// from: public java.lang.String getHostAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getHostAddress() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHostAddress, jni.JniCallType.objectType, []).object);
  }

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"hashCode", r"()I");

  /// from: public int hashCode()
  int hashCode1() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;
  }

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"equals", r"(Ljava/lang/Object;)Z");

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;
  }

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"toString", r"()Ljava/lang/String;");

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);
  }

  static final _id_getByAddress = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getByAddress",
      r"(Ljava/lang/String;[B)Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress getByAddress(java.lang.String string, byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static InetAddress getByAddress(
    jni.JString string,
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $InetAddressType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_getByAddress,
            jni.JniCallType.objectType,
            [string.reference, bs.reference]).object);
  }

  static final _id_getByName = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getByName",
      r"(Ljava/lang/String;)Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress getByName(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static InetAddress getByName(
    jni.JString string,
  ) {
    return const $InetAddressType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getByName,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getAllByName = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getAllByName",
      r"(Ljava/lang/String;)[Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress[] getAllByName(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JArray<InetAddress> getAllByName(
    jni.JString string,
  ) {
    return const jni.JArrayType($InetAddressType()).fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getAllByName,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getLoopbackAddress = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getLoopbackAddress", r"()Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress getLoopbackAddress()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static InetAddress getLoopbackAddress() {
    return const $InetAddressType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getLoopbackAddress,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_getByAddress1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getByAddress", r"([B)Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress getByAddress(byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static InetAddress getByAddress1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return const $InetAddressType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getByAddress1,
            jni.JniCallType.objectType, [bs.reference]).object);
  }

  static final _id_getLocalHost = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getLocalHost", r"()Ljava/net/InetAddress;");

  /// from: static public java.net.InetAddress getLocalHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static InetAddress getLocalHost() {
    return const $InetAddressType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getLocalHost,
            jni.JniCallType.objectType, []).object);
  }
}

class $InetAddressType extends jni.JObjType<InetAddress> {
  const $InetAddressType();

  @override
  String get signature => r"Ljava/net/InetAddress;";

  @override
  InetAddress fromRef(jni.JObjectPtr ref) => InetAddress.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InetAddressType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InetAddressType) && other is $InetAddressType;
  }
}
